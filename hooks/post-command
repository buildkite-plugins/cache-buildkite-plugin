#!/bin/bash
set -euo pipefail

# skip caching if command exited non-zero
if [ "${BUILDKITE_COMMAND_EXIT_STATUS}" -ne 0 ] ; then
  echo "Aborting cache post-command hook because command exited with status $BUILDKITE_COMMAND_EXIT_STATUS"
  exit 0
fi

DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

# shellcheck source=lib/shared.bash
. "${DIR}/../lib/shared.bash"
# shellcheck source=lib/compression.bash
. "${DIR}/../lib/compression.bash"

CACHE_PATH=$(plugin_read_config PATH)

if [ -z "${CACHE_PATH}" ] ; then
  echo "+++ ðŸš¨ Missing path option in the cache plugin to save"
  exit 1
fi

COMPRESS=$(plugin_read_config COMPRESSION 'none')

if ! plugin_read_list_into_result SAVE; then
  echo 'Cache not setup for saving'
  exit 0
fi

ORDERED_LEVELS=(file step branch pipeline all)
SAVE_LEVELS=()

# array intersection keeping the order of the first array
for O_LEVEL in "${ORDERED_LEVELS[@]}"; do
  for R_LEVEL in "${result[@]}"; do
    if [ "${O_LEVEL}" = "${R_LEVEL}" ]; then
      SAVE_LEVELS+=("${O_LEVEL}")
    fi
  done
done

if [ "${#SAVE_LEVELS[@]}" -ne "${#result[@]}" ]; then
  echo 'Invalid levels in the save list'
  exit 1
fi

# Validate manifest is present for file-level caching (config validation - always fails)
for LEVEL in "${SAVE_LEVELS[@]}"; do
  if [ "${LEVEL}" = 'file' ] && [ -z "$(plugin_read_list MANIFEST)" ]; then
    echo "+++ ðŸš¨ Missing manifest option in the cache plugin for file-level saving"
    exit 1
  fi
done

perform_save() {
  # Check if cache path exists before attempting to save
  if [ ! -e "${CACHE_PATH}" ]; then
    echo "+++ ðŸš¨ Cache path '${CACHE_PATH}' does not exist"
    return 1
  fi

  local ACTUAL_PATH="${CACHE_PATH}"
  local lower_level_updated='false'
  local already_compressed='false'

  for LEVEL in "${SAVE_LEVELS[@]}"; do
    # this validates the level as well
    KEY=$(build_key "${LEVEL}" "${CACHE_PATH}" "${COMPRESS}")

    if [ "$(plugin_read_config FORCE 'false')" != 'false' ] ||
       [ "${lower_level_updated}" = 'true' ] ||
       ! backend_exec exists "${KEY}"; then
      echo "Saving ${LEVEL}-level cache of ${CACHE_PATH}"
      if compression_active && [ "${already_compressed}" = 'false' ]; then
        ACTUAL_PATH=$(mktemp)

        # TERM in case it is cancelled
        # EXIT when the script ends
        # shellcheck disable=SC2064 # we want the expansion to happen now
        trap "cleanup_compression_tempfile '${ACTUAL_PATH}'" TERM EXIT

        compress "${CACHE_PATH}" "${ACTUAL_PATH}" || return 1
        already_compressed='true' # avoid re-compressing the files
      fi
      backend_exec save "${KEY}" "${ACTUAL_PATH}" || return 1
      lower_level_updated='true' # to force saving higher levels
    else
      echo "Cache of ${LEVEL} already exists, skipping"
    fi
  done
}

soft_fail_exec "save" perform_save
